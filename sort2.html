<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Merge + Quick Sort å‹•ç•«æ¨¡æ“¬å™¨</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; padding: 2rem; }
    .container { background: #fff; padding: 2rem; max-width: 960px; margin: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
    .highlight { background-color: #4caf50; color: white; }
    table { width: 100%; margin-top: 1rem; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .code-box { background: #272822; color: #f8f8f2; padding: 1rem; border-radius: 6px; margin-top: 1rem; font-family: monospace; white-space: pre-wrap; }
    .active-code { background-color: #444; }
    .analysis { background: #eef7ff; padding: 1rem; margin-top: 1rem; border-left: 5px solid #007acc; }
  </style>
</head>
<body>
<div class="container">
  <h2>MergeSort / QuickSort å‹•ç•«æ¨¡æ“¬å™¨</h2>
  <select id="algoSelect" onchange="init()">
    <option value="merge">ğŸ§µ MergeSort</option>
    <option value="quick">âš¡ QuickSort</option>
  </select>
  <input type="text" id="arrayInput" value="5,3,8,4,2">
  <button onclick="init()">ğŸ”ƒ é‡è¨­</button>
  <button onclick="step()">ğŸ§­ ä¸‹ä¸€æ­¥</button>

  <table>
    <thead><tr><th>ç´¢å¼•</th><th>å€¼</th><th>ç‹€æ…‹</th></tr></thead>
    <tbody id="arrayTable"></tbody>
  </table>

  <div id="subarrayBox" class="analysis"></div>
  <div class="code-box" id="codeBox"></div>
  <div class="analysis" id="analysisBox"></div>
</div>

<script>
let arr = [], ops = [], algo = 'merge';
let mergeState = null;
let quickStack = [], quickState = null;

function safeGet(id) {
  return document.getElementById(id);
}

function updateSubarrays(L, R, mode = '', info = '', l = null, r = null) {
  const box = safeGet("subarrayBox");
  if (!box) return;
  box.innerHTML = `
    <strong>ğŸ” å­é™£åˆ—ç‹€æ…‹</strong><br>
    æ¨¡å¼ï¼š${mode}<br>
    ${info ? info + '<br>' : ''}
    ${l !== null && r !== null ? `ç´¢å¼•ç¯„åœï¼šl = ${l}, r = ${r}<br>` : ''}
    å·¦é™£åˆ— (L)ï¼š[${L.join(', ')}]<br>
    å³é™£åˆ— (R)ï¼š[${R.join(', ')}]
  `;
}

function highlight(line) {
  const code = safeGet("codeBox");
  if (!code) return;
  code.innerHTML = code.innerHTML.split('\n').map((ln, idx) => {
    return "<span class='" + (idx + 1 === line ? "active-code" : "") + "'>" + ln + "</span>";
  }).join('\n');
}

function renderTable(iPtr = -1, jPtr = -1, pivotPtr = -1) {
  const tbody = safeGet("arrayTable");
  if (!tbody) return;
  tbody.innerHTML = "";
  arr.forEach((val, idx) => {
    const row = document.createElement("tr");
    const t1 = document.createElement("td");
    const t2 = document.createElement("td");
    const t3 = document.createElement("td");
    t1.textContent = idx;
    t2.textContent = val;
    let tags = [];
    if (idx === iPtr) tags.push("ğŸ”µ i");
    if (idx === jPtr) tags.push("ğŸ”´ j");
    if (idx === pivotPtr) tags.push("ğŸ¯ pivot");
    t3.textContent = tags.join(" ");
    if (tags.length > 0) t2.classList.add("highlight");
    row.appendChild(t1); row.appendChild(t2); row.appendChild(t3);
    tbody.appendChild(row);
  });
}

function init() {
  const arrayInput = safeGet("arrayInput");
  const algoSelect = safeGet("algoSelect");
  if (!arrayInput || !algoSelect) return;

  arr = arrayInput.value.split(',').map(Number);
  algo = algoSelect.value;
  mergeState = null;
  quickStack = [];
  quickState = null;
  updateSubarrays([], []);
  ops = [];

  if (algo === 'merge') {
    mergeSortOps(0, arr.length - 1);
    updateCode('merge');
    updateAnalysis('merge');
  } else {
    quickStack.push([0, arr.length - 1]);
    updateCode('quick');
    updateAnalysis('quick');
  }

  renderTable();
}

function step() {
  if (algo === 'merge') {
    if (!mergeState && ops.length > 0) {
      const { l, m, r } = ops.pop();
      const L = arr.slice(l, m + 1);
      const R = arr.slice(m + 1, r + 1);
      mergeState = { l, m, r, L, R, i: 0, j: 0, k: l, state: 'compare' };
      updateSubarrays(L, R, "MergeSort", `mid = ${m}`, l, r);
      highlight(13);
      renderTable(l, r);
    } else if (mergeState) {
      let { L, R, i, j, k, l, r, state } = mergeState;
      if (state === 'compare') {
        if (i < L.length && j < R.length) {
          if (L[i] <= R[j]) {
            arr[k++] = L[i++];
            highlight(15);
          } else {
            arr[k++] = R[j++];
            highlight(17);
          }
        } else {
          mergeState.state = 'leftoverL';
        }
      } else if (state === 'leftoverL') {
        if (i < L.length) {
          arr[k++] = L[i++];
          highlight(19);
        } else {
          mergeState.state = 'leftoverR';
        }
      } else if (state === 'leftoverR') {
        if (j < R.length) {
          arr[k++] = R[j++];
          highlight(20);
        } else {
          mergeState = null;
          highlight(6);
          renderTable();
          return;
        }
      }
      mergeState.i = i;
      mergeState.j = j;
      mergeState.k = k;
      renderTable(l, r);
    }
  }

  if (algo === 'quick') {
    if (!quickState && quickStack.length > 0) {
      const [low, high] = quickStack.pop();
      if (low >= high) return;
      quickState = { low, high, i: low, j: low, pivot: arr[high], done: false };

      // åœ¨ç¬¬ä¸€æ¬¡åˆ‡å‰²æ™‚ï¼Œåªé¡¯ç¤ºæ­£åœ¨é€²è¡Œ partitionï¼Œå°šæœªé¡¯ç¤º L å’Œ R
      updateSubarrays([], [], "æ­£åœ¨åš partition", `pivot = ${arr[high]}`, low, high);
      highlight(9);  // æ¨™ç¤ºç•¶å‰é€²è¡Œçš„æ“ä½œ
      renderTable(low, low, high);
    } else if (quickState && !quickState.done) {
      let s = quickState;
      if (s.j < s.high) {
        if (arr[s.j] <= s.pivot) {
          [arr[s.i], arr[s.j]] = [arr[s.j], arr[s.i]];
          s.i++;
        }
        s.j++;

        // åœ¨é€²è¡Œ partition éç¨‹æ™‚ï¼Œä¸é¡¯ç¤º L å’Œ R
        updateSubarrays([], [], "æ­£åœ¨åš partition", `pivot = ${s.pivot}`, s.low, s.high);
        highlight(13);  // æ¨™ç¤ºç•¶å‰é€²è¡Œçš„æ“ä½œ
        renderTable(s.i, s.j, s.high);
      } else {
        // å®Œæˆ partitionï¼Œå°‡ pivot æ”¾åˆ°æ­£ç¢ºä½ç½®
        [arr[s.i], arr[s.high]] = [arr[s.high], arr[s.i]];
        quickStack.push([s.low, s.i - 1]);
        quickStack.push([s.i + 1, s.high]);
        quickState = null;

        // åœ¨ partition å®Œæˆå¾Œï¼Œé¡¯ç¤º L å’Œ R
        const L = arr.slice(s.low, s.i);  // å°æ–¼ç­‰æ–¼ pivot çš„éƒ¨åˆ†
        const R = arr.slice(s.i + 1, s.high + 1);  // å¤§æ–¼ pivot çš„éƒ¨åˆ†
        updateSubarrays(L, R, "QuickSort", `pivot = ${arr[s.i]}`, s.low, s.high);

        highlight(17);  // å®Œæˆçš„æ“ä½œæ¨™ç¤º
        renderTable();
      }
    }
  }
}

function mergeSortOps(l, r) {
  if (l < r) {
    const m = Math.floor((l + r) / 2);
    ops.push({ l, m, r });
    mergeSortOps(m + 1, r);
    mergeSortOps(l, m);
  }
}

function updateCode(type) {
  const code = safeGet("codeBox");
  if (!code) return;
  if (type === 'merge') {
    code.innerHTML = `
1: void mergeSort(int arr[], int l, int r) {
2:   if (l < r) {
3:     int m = (l + r) / 2;
4:     mergeSort(arr, l, m);
5:     mergeSort(arr, m + 1, r);
6:     merge(arr, l, m, r);
7:   }
8: }

9: void merge(...) {
10: int L[], R[];
11: copy to L and R;
12: int i = 0, j = 0, k = l;
13: while (i < L.length && j < R.length) {
14:   if (L[i] <= R[j])
15:     arr[k++] = L[i++];
16:   else
17:     arr[k++] = R[j++];
18: }
19: while (i < L.length) arr[k++] = L[i++];
20: while (j < R.length) arr[k++] = R[j++];
21: }`;
  } else {
    code.innerHTML = `
1: void quickSort(int arr[], int low, int high) {
2:   if (low < high) {
3:     int pi = partition(arr, low, high);
4:     quickSort(arr, low, pi - 1);
5:     quickSort(arr, pi + 1, high);
6:   }
7: }

8: int partition(int arr[], int low, int high) {
9:   int pivot = arr[high];
10:  int i = low;
11:  for (int j = low; j < high; j++) {
12:    if (arr[j] <= pivot) {
13:      swap(arr[i], arr[j]);
14:      i++;
15:    }
16:  }
17:  swap(arr[i], arr[high]);
18:  return i;
19: }`;
  }
}

function updateAnalysis(type) {
  const box = safeGet("analysisBox");
  if (!box) return;
  if (type === 'merge') {
    box.innerHTML = `ğŸ§µ <strong>MergeSort åˆ†æ</strong><br><br>
    ğŸ“ˆ æ™‚é–“è¤‡é›œåº¦ï¼š<br>
    O(n log n)ï¼ˆæ‰€æœ‰æƒ…æ³çš†ç‚ºæ­¤ï¼‰<br><br>
    ğŸ’¾ ç©ºé–“è¤‡é›œåº¦ï¼š<br>
    O(n)ï¼ˆéœ€é¡å¤–æš«å­˜é™£åˆ—ï¼‰<br><br>
    ğŸ“Œ è£œå……èªªæ˜ï¼š<br>
    ä½¿ç”¨åˆ†æ²»æ³•éè¿´åˆ‡å‰²å†åˆä½µã€‚<br>
    å±¬æ–¼ç©©å®šæ’åºï¼Œä½†ç©ºé–“ä½¿ç”¨è¼ƒé«˜ã€‚`;
  } else {
    box.innerHTML = `âš¡ <strong>QuickSort åˆ†æ</strong><br><br>
    ğŸ“ˆ æ™‚é–“è¤‡é›œåº¦ï¼š<br>
    å¹³å‡ï¼šO(n log n)<br>
    æœ€å·®ï¼šO(nÂ²)ï¼ˆpivot é¸ä¸å¥½æ™‚ï¼‰<br><br>
    ğŸ’¾ ç©ºé–“è¤‡é›œåº¦ï¼š<br>
    O(log n)ï¼ˆä¾†è‡ªéè¿´å †ç–Šç©ºé–“ï¼‰<br><br>
    ğŸ“Œ è£œå……èªªæ˜ï¼š<br>
    ä»¥ pivot ç‚ºåŸºæº–åˆ†å‰²å­é™£åˆ—ã€‚<br>
    å±¬æ–¼ä¸ç©©å®šæ’åºï¼Œä½†åŸåœ°æ’åºä¸”æ•ˆç‡é«˜ã€‚`;
  }
}

window.onload = () => {
  if (
    safeGet("arrayInput") &&
    safeGet("algoSelect") &&
    safeGet("arrayTable") &&
    safeGet("codeBox") &&
    safeGet("analysisBox") &&
    safeGet("subarrayBox")
  ) {
    init();
  }
};
</script>
</body>
</html>

    
    


    

